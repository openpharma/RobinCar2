<!DOCTYPE html>
<!-- Generated by pkgdown + https://github.com/insightsengineering/r-pkgdown-multiversion -->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Survival Analysis with RobinCar2 • RobinCar2</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Survival Analysis with RobinCar2">
<!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-125641273-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-125641273-1');
</script>
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">RobinCar2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/intro.html">Package Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/robincar-comparison.html">Generalized Linear Regression in RobinCar and RobinCar2</a></li>
    <li><a class="dropdown-item" href="../articles/robincar-survival.html">Survival Analysis with RobinCar2</a></li>
    <li><a class="dropdown-item" href="../articles/robincar-validate.html">RobinCar2 Validation Report</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      <div><li class="nav-item dropdown">
    <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-versions">Versions</a>
    <div class="dropdown-menu" aria-labelledby="dropdown-versions">
    <a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/release-candidate">release-candidate</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/main">main</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/latest-tag">latest-tag</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.2.1-rc1">v0.2.1-rc1</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.2.0">v0.2.0</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.2.0-rc2">v0.2.0-rc2</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.2.0-rc1">v0.2.0-rc1</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.1.1">v0.1.1</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.1.1-rc6">v0.1.1-rc6</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.1.1-rc5">v0.1.1-rc5</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.1.1-rc4">v0.1.1-rc4</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.1.1-rc3">v0.1.1-rc3</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.1.1-rc2">v0.1.1-rc2</a>
<a class="dropdown-item" data-toggle="tooltip" title="" href="https://openpharma.github.io/RobinCar2/v0.1.1-rc1">v0.1.1-rc1</a>
</div>
</li></div>
</ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/openpharma/RobinCar2" aria-label="github"><span class="fa fa-github"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Survival Analysis with RobinCar2</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/openpharma/RobinCar2/blob/main/vignettes/articles/robincar-survival.Rmd" class="external-link"><code>vignettes/articles/robincar-survival.Rmd</code></a></small>
      <div class="d-none name"><code>robincar-survival.Rmd</code></div>
    </div>

    
    
<p><code>RobinCar2</code> implements survival analysis methods for
testing treatment effects with log-rank tests and estimating hazard
ratios using score functions. This vignette provides an overview of the
underlying algorithms.</p>
<div class="section level2">
<h2 id="overview-of-survival-analysis-methods">Overview of Survival Analysis Methods<a class="anchor" aria-label="anchor" href="#overview-of-survival-analysis-methods"></a>
</h2>
<p>Survival analysis is performed with the <code>robin_surv</code>
function, and the syntax is:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/robin_surv.html">robin_surv</a></span><span class="op">(</span></span>
<span>  <span class="fu">Surv</span><span class="op">(</span><span class="va">time</span>, <span class="va">event</span><span class="op">)</span> <span class="op">~</span> <span class="va">covariates</span>,</span>
<span>  treatment <span class="op">=</span> <span class="va">group</span> <span class="op">~</span> <span class="va">strata</span>,</span>
<span>  data <span class="op">=</span> <span class="va">df</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>When there are no covariates or strata, then these can just be
replaced by an intercept (<code>1</code>) term, respectively. Depending
on the choice of <code>strata</code> and <code>covariates</code>, the
following four methods are available:</p>
<ul>
<li>Standard log-rank test without strata or covariates by omitting
<code>strata</code> and <code>covariates</code>
</li>
<li>Stratified log-rank test by specifying <code>strata</code> but no
<code>covariates</code>
</li>
<li>Covariate adjusted log-rank test by specifying
<code>covariates</code> but no <code>strata</code>
</li>
<li>Covariate adjusted and stratified log-rank test by specifying both
<code>strata</code> and <code>covariates</code>
</li>
</ul>
<p>Let’s go through these in a simple example. We start with the
standard log-rank test:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/openpharma/RobinCar2/" class="external-link">RobinCar2</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/robin_surv.html">robin_surv</a></span><span class="op">(</span></span>
<span>  <span class="fu">Surv</span><span class="op">(</span><span class="va">time</span>, <span class="va">status</span><span class="op">)</span> <span class="op">~</span> <span class="fl">1</span>,</span>
<span>  treatment <span class="op">=</span> <span class="va">sex</span> <span class="op">~</span> <span class="fl">1</span>,</span>
<span>  data <span class="op">=</span> <span class="va">surv_data</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Model        :  Surv(time, status) ~ 1 </span></span>
<span><span class="co">#&gt; Randomization:  sex ~ 1  ( Simple )</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Contrast     :  Log Hazard ratio</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Estimate Std.Err Z Value Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female  0.53343 0.16727   3.189 0.001428 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Test         :  Log-Rank</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Test Stat. Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female     3.2135 0.001311 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre></div>
<p>We can perform the stratified log-rank test by adding a
<code>strata</code> right-hand side in the <code>treatment</code>
formula:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/robin_surv.html">robin_surv</a></span><span class="op">(</span></span>
<span>  <span class="fu">Surv</span><span class="op">(</span><span class="va">time</span>, <span class="va">status</span><span class="op">)</span> <span class="op">~</span> <span class="fl">1</span>,</span>
<span>  treatment <span class="op">=</span> <span class="va">sex</span> <span class="op">~</span> <span class="va">strata</span>,</span>
<span>  data <span class="op">=</span> <span class="va">surv_data</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Model        :  Surv(time, status) ~ 1 </span></span>
<span><span class="co">#&gt; Randomization:  sex ~ strata  ( Simple )</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Contrast     :  Log Hazard ratio</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Estimate Std.Err Z Value Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female  0.55482 0.17063  3.2516 0.001147 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Test         :  Log-Rank</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Test Stat. Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female     3.2856 0.001018 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre></div>
<p>We can also use multiple stratification variables by adding them on
the right-hand side of <code>treatment</code>, as follows:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/robin_surv.html">robin_surv</a></span><span class="op">(</span></span>
<span>  <span class="fu">Surv</span><span class="op">(</span><span class="va">time</span>, <span class="va">status</span><span class="op">)</span> <span class="op">~</span> <span class="fl">1</span>,</span>
<span>  treatment <span class="op">=</span> <span class="va">sex</span> <span class="op">~</span> <span class="va">strata</span> <span class="op">+</span> <span class="va">ecog</span>,</span>
<span>  data <span class="op">=</span> <span class="va">surv_data</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Model        :  Surv(time, status) ~ 1 </span></span>
<span><span class="co">#&gt; Randomization:  sex ~ strata + ecog  ( Simple )</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Contrast     :  Log Hazard ratio</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Estimate Std.Err Z Value Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female  0.55482 0.17063  3.2516 0.001147 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Test         :  Log-Rank</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Test Stat. Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female     3.2856 0.001018 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre></div>
<p>We could also just use covariate adjustment:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/robin_surv.html">robin_surv</a></span><span class="op">(</span></span>
<span>  <span class="fu">Surv</span><span class="op">(</span><span class="va">time</span>, <span class="va">status</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">meal.cal</span>,</span>
<span>  treatment <span class="op">=</span> <span class="va">sex</span> <span class="op">~</span> <span class="fl">1</span>,</span>
<span>  data <span class="op">=</span> <span class="va">surv_data</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Model        :  Surv(time, status) ~ age + meal.cal </span></span>
<span><span class="co">#&gt; Randomization:  sex ~ 1  ( Simple )</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Contrast     :  Log Hazard ratio</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Estimate Std.Err Z Value Pr(&gt;|z|)  </span></span>
<span><span class="co">#&gt; Male v.s. Female  0.47686 0.18608  2.5626  0.01039 *</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Test         :  Log-Rank</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Test Stat. Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female     2.6858 0.007236 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre></div>
<p>Or we combine both stratification and covariate adjustment:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/robin_surv.html">robin_surv</a></span><span class="op">(</span></span>
<span>  <span class="fu">Surv</span><span class="op">(</span><span class="va">time</span>, <span class="va">status</span><span class="op">)</span> <span class="op">~</span> <span class="va">age</span> <span class="op">+</span> <span class="va">meal.cal</span>,</span>
<span>  treatment <span class="op">=</span> <span class="va">sex</span> <span class="op">~</span> <span class="va">strata</span> <span class="op">+</span> <span class="va">ecog</span>,</span>
<span>  data <span class="op">=</span> <span class="va">surv_data</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Model        :  Surv(time, status) ~ age + meal.cal </span></span>
<span><span class="co">#&gt; Randomization:  sex ~ strata + ecog  ( Simple )</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Contrast     :  Log Hazard ratio</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Estimate Std.Err Z Value Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female  0.55219 0.19133  2.8861   0.0039 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Test         :  Log-Rank</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;                  Test Stat. Pr(&gt;|z|)   </span></span>
<span><span class="co">#&gt; Male v.s. Female     2.9496 0.003181 **</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="details-of-the-methods">Details of the Methods<a class="anchor" aria-label="anchor" href="#details-of-the-methods"></a>
</h2>
<p>The four methods introduced above are implemented based on the
corresponding score functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U(\theta)</annotation></semantics></math>
with corresponding variance estimators
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma^{2}(\theta)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
is the log hazard ratio.</p>
<p>The log-rank test statistic is defined as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒯</mi><mi>L</mi></msub><mo>=</mo><msqrt><mi>n</mi></msqrt><msub><mi>U</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mi>/</mi><msub><mi>σ</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\mathcal{T}_{L} = \sqrt{n} U_{L}(0) / \sigma_{L}(0)
</annotation></semantics></math></p>
<p>and it asymptotically follows a standard normal distribution under
the null hypothesis of no treatment effect,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta = 0</annotation></semantics></math>.</p>
<p>For estimation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>,
we find the root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>θ</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math>
of the score function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U(\theta)</annotation></semantics></math>
such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false" form="prefix">(</mo><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">U(\hat{\theta}) = 0</annotation></semantics></math>.
The standard error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>θ</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\theta}</annotation></semantics></math>
is derived from the variance estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">(</mo><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma(\hat{\theta})</annotation></semantics></math>,
with specific formulas depending on the method used and detailed
below.</p>
<div class="section level3">
<h3 id="standard-analysis-without-strata-or-covariates">Standard analysis without strata or covariates<a class="anchor" aria-label="anchor" href="#standard-analysis-without-strata-or-covariates"></a>
</h3>
<p>Following Section 2 in <span class="citation">Ye, Shao, and Yi
(2023)</span>, the score function from the partial likelihood under the
Cox proportional hazards model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>λ</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda_{1}(t) = \lambda_{0}(t) \exp(\theta)</annotation></semantics></math>
is given by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>U</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mo>∫</mo><mn>0</mn><mi>τ</mi></msubsup><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>I</mi><mi>i</mi></msub><mo>−</mo><mfrac><mrow><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mi>d</mi><msub><mi>N</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>I</mi><mi>j</mi></msub><mo>−</mo><mfrac><mrow><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
U_{L}(\theta) 
&amp;= 
\frac{1}{n} \sum_{i=1}^{n} \int_{0}^{\tau} 
\left\{
I_{i} - \frac{\exp(\theta) \overline{Y}_{1}(t)}{\overline{Y}_{0}(t) + \exp(\theta) \overline{Y}_{1}(t)}
\right\}
dN_i(t)\\
&amp;=
\frac{1}{n} \sum_{j=1}^{m}
I_{j} - \frac{\exp(\theta) \overline{Y}_{1}(t_{j})}{\overline{Y}_{0}(t_{j}) + \exp(\theta) \overline{Y}_{1}(t_{j})}
\end{align*}
</annotation></semantics></math></p>
<p>where we switched from the summation over all patients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i = 1, \dotsc, n</annotation></semantics></math>
to the summation over all patients with events
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">j = 1, \dotsc, m</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \leq n</annotation></semantics></math>.
The treatment indicator is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>j</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">I_{j} = 1</annotation></semantics></math>
if patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is in treatment group 1, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>j</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">I_{j} = 0</annotation></semantics></math>
if patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is in treatment group 0. The proportions of patients at risk at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>j</mi></msub><annotation encoding="application/x-tex">t_{j}</annotation></semantics></math>,
per arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 0, 1</annotation></semantics></math>
is given by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>k</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>𝕀</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>I</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo><mi>𝕀</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\overline{Y}_{k}(t_{j}) = \frac{1}{n} \sum_{i=1}^{n} \mathbb{I}(I_{i} = k) \mathbb{I}(t_{i} \geq t_{j})
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_{i}</annotation></semantics></math>
is the potentially right-censored time of patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝕀</mi><mo stretchy="false" form="prefix">(</mo><mi>⋅</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbb{I}(\cdot)</annotation></semantics></math>
is the indicator function.</p>
<p>The corresponding variance estimate is given by this adapted version
using the correction factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">c_{\theta}(t)</annotation></semantics></math>
which accounts for ties in the survival times in the log-rank test.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mo>∫</mo><mn>0</mn><mi>τ</mi></msubsup><mfrac><mrow><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>c</mi><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow></mfrac><mi>d</mi><msub><mi>N</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mfrac><mrow><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><msub><mi>c</mi><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
\sigma_{L}^{2}(\theta)
&amp;=
\frac{1}{n} \sum_{i=1}^{n} \int_{0}^{\tau}
\frac{\exp(\theta) \overline{Y}_{0}(t) \overline{Y}_{1}(t) c_{\theta}(t)}{\overline{Y}_{\theta}(t)^{2}}
dN_i(t)
\\
&amp;= 
\frac{1}{n} \sum_{j=1}^{m}
\frac{\exp(\theta) \overline{Y}_{0}(t_{j}) \overline{Y}_{1}(t_{j}) c_{\theta}(t_{j})}{\overline{Y}_{\theta}(t_{j})^{2}}
\end{align*}
</annotation></semantics></math></p>
<p>where we abbreviated</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\overline{Y}_{\theta}(t) = \overline{Y}_{0}(t) + \exp(\theta) \overline{Y}_{1}(t)
</annotation></semantics></math></p>
<p>and similarly</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
\overline{Y}_{\theta}(t_{j}) = \overline{Y}_{0}(t_{j}) + \exp(\theta) \overline{Y}_{1}(t_{j}).
</annotation></semantics></math></p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>δ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\delta_{i}</annotation></semantics></math>
be the binary event indicator for patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
and let the number of events at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>j</mi></msub><annotation encoding="application/x-tex">t_{j}</annotation></semantics></math>
be denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>δ</mi><mi>i</mi></msub><mi>𝕀</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">m(t_{j}) = \sum_{i=1}^{n} \delta_{i} \mathbb{I}(t_{i} = t_{j})</annotation></semantics></math>.
We define then the correction factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">c_{\theta}(t_{j})</annotation></semantics></math>
as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>m</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mi>n</mi><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mi>m</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>n</mi><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mn>1</mn></mrow></mfrac></mtd><mtd columnalign="left" style="text-align: left"><mrow><mtext mathvariant="normal">if </mtext><mspace width="0.333em"></mspace></mrow><mi>m</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>&gt;</mo><mn>1</mn></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
c_{\theta}(t_{j}) = 
\begin{cases}
1 &amp; \text{if } m(t_{j}) = 1 \\
\frac{n \overline{Y}_{\theta}(t_{j}) - m(t_{j})}{n \overline{Y}_{\theta}(t_{j}) - 1} &amp; \text{if } m(t_{j}) &gt; 1
\end{cases}
</annotation></semantics></math></p>
<p>Furthermore, we note that this correction factor is only used when
calculating the log-rank test statistic, which is given at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta = 0</annotation></semantics></math>
by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝒯</mi><mi>L</mi></msub><mo>=</mo><msqrt><mi>n</mi></msqrt><msub><mi>U</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mi>/</mi><msub><mi>σ</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathcal{T}_{L} = \sqrt{n} U_{L}(0) / \sigma_{L}(0).
</annotation></semantics></math></p>
<p>However, when we estimate the log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
by finding the root
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><annotation encoding="application/x-tex">\hat{\theta}_{L}</annotation></semantics></math>
of the score function such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">U_{L}(\hat{\theta}_{L}) = 0</annotation></semantics></math>,
we set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>≡</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c_{\theta}(t_{j}) \equiv 1</annotation></semantics></math>.</p>
<p>The standard error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><annotation encoding="application/x-tex">\hat{\theta}_{L}</annotation></semantics></math>
is given by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><msqrt><mi>n</mi></msqrt><msub><mi>σ</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\frac{1}{\sqrt{n} \sigma_{L}(\hat{\theta}_{L})}.
</annotation></semantics></math></p>
<p>This score function and the variance estimator are implemented in the
internal function
<code>RobinCar2:::h_lr_score_no_strata_no_cov()</code>.</p>
</div>
<div class="section level3">
<h3 id="stratified-analysis-without-covariates">Stratified analysis without covariates<a class="anchor" aria-label="anchor" href="#stratified-analysis-without-covariates"></a>
</h3>
<p>Following Section S2.3 in <span class="citation">Ye, Shao, and Yi
(2023)</span>, the score function for the stratified log-rank test is
given by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>U</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munder><mo>∑</mo><mi>z</mi></munder><munder><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><msub><mi>Z</mi><mi>i</mi></msub><mo>=</mo><mi>z</mi></mrow></munder><msubsup><mo>∫</mo><mn>0</mn><mi>τ</mi></msubsup><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>I</mi><mi>i</mi></msub><mo>−</mo><mfrac><mrow><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>0</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">}</mo></mrow><mi>d</mi><msub><mi>N</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munder><mo>∑</mo><mi>z</mi></munder><munder><mo>∑</mo><mrow><mi>j</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow></munder><msub><mi>I</mi><mi>j</mi></msub><mo>−</mo><mfrac><mrow><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>0</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
U_{SL}(\theta) 
&amp;= 
\frac{1}{n} \sum_{z} \sum_{i: Z_{i} = z} \int_{0}^{\tau} 
\left\{
I_{i} - \frac{\exp(\theta) \overline{Y}_{z1}(t)}{\overline{Y}_{z0}(t) + \exp(\theta) \overline{Y}_{z1}(t)}
\right\}
dN_i(t)\\
&amp;=
\frac{1}{n} \sum_{z} \sum_{j(z)}
I_{j} - \frac{\exp(\theta) \overline{Y}_{z1}(t_{j})}{\overline{Y}_{z0}(t_{j}) + \exp(\theta) \overline{Y}_{z1}(t_{j})}
\end{align*}
</annotation></semantics></math></p>
<p>where the last sum is over the unique event times
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
in stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>,
therefore written here simply as indices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">j(z)</annotation></semantics></math>.
The proportions of patients at risk at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>j</mi></msub><annotation encoding="application/x-tex">t_{j}</annotation></semantics></math>,
per arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 0, 1</annotation></semantics></math>
in stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
are denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\overline{Y}_{zk}(t_{j})</annotation></semantics></math>.
Importantly, the proportion is with regards to the total number of
patients across all strata, not just within stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>.</p>
<p>So we can see that the score function is a sum over strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
of the standard log-rank score function. In the same way, the variance
estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{SL}^{2}(\theta)</annotation></semantics></math>
is the sum over strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
of the standard log-rank variance estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{L}^{2}(\theta)</annotation></semantics></math>.</p>
<p>The standard error of the correspondingly estimated log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{SL}</annotation></semantics></math>
is given by</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><msqrt><mi>n</mi></msqrt><msub><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
\frac{1}{\sqrt{n} \sigma_{SL}(\hat{\theta}_{SL})}.
</annotation></semantics></math></p>
<p>One small important detail is that the number of patients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
in the denominator is always the total number of patients across all
strata, not the number of patients in stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>.
This is the reason why the standard log-rank score function
<code>RobinCar2:::h_lr_score_no_strata_no_cov()</code> has an argument
<code>n</code>, which is used here by the stratified log-rank score
function <code>RobinCar2:::h_lr_score_strat()</code> to pass on the
total number of patients.</p>
</div>
<div class="section level3">
<h3 id="covariate-adjusted-analysis-without-strata">Covariate adjusted analysis without strata<a class="anchor" aria-label="anchor" href="#covariate-adjusted-analysis-without-strata"></a>
</h3>
<p>A little bit more complex is the calculation of the score function
for the covariate adjusted log-rank test, which following Section 3 in
<span class="citation">Ye, Shao, and Yi (2023)</span> is given by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>C</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>U</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false" form="prefix">{</mo><msub><mi>I</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mover><mi>X</mi><mo accent="true">¯</mo></mover><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>I</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mover><mi>X</mi><mo accent="true">¯</mo></mover><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
U_{CL}(\theta) =
U_{L}(\theta) - \frac{1}{n} \sum_{i=1}^{n} 
\{
I_{i}(X_{i} - \overline{X})^{\top} \hat{\beta}_{1}(\theta_{L}) - 
(1 - I_{i})(X_{i} - \overline{X})^{\top} \hat{\beta}_{0}(\theta_{L}) 
\}.
</annotation></semantics></math></p>
<p>Here we have to explain a lot of notation. The score function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>C</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U_{CL}(\theta)</annotation></semantics></math>
is based on the standard log-rank score function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>L</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U_{L}(\theta)</annotation></semantics></math>,
but we subtract a correction term that accounts for the covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_{i}</annotation></semantics></math>
of patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
The covariates are assumed to be centered,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>X</mi><mo accent="true">¯</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\overline{X} = \frac{1}{n} \sum_{i=1}^{n} X_{i}</annotation></semantics></math>
is the mean of the covariates across all patients.</p>
<p>Interestingly on the right hand side we see also
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>L</mi></msub><annotation encoding="application/x-tex">\theta_{L}</annotation></semantics></math>.
This is supposed to be the log hazard ratio estimated by the standard
log-rank analysis,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><annotation encoding="application/x-tex">\hat{\theta}_{L}</annotation></semantics></math>,
when finding the root of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>C</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U_{CL}(\theta)</annotation></semantics></math>
to estimate the log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CL}</annotation></semantics></math>.
The reason for this is that the asymptotic guaranteed efficiency gain of
the covariate adjusted log hazard ratio estimator is only proven using
this version of the score function, see Section 3 in <span class="citation">Ye, Shao, and Yi (2023)</span>. On the other hand, for
calculating the covariate adjusted log-rank score test statistic, we set
both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta = 0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>L</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_{L} = 0</annotation></semantics></math>.</p>
<p>How are the regression coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><annotation encoding="application/x-tex">\hat{\beta}_{1}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><annotation encoding="application/x-tex">\hat{\beta}_{0}</annotation></semantics></math>
in the correction term estimated given a log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>?</p>
<p>First, the so-called derived outcomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">O_{ik}</annotation></semantics></math>
for patients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and arms
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=0,1</annotation></semantics></math>
need to be calculated. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Y_{ik}(t)</annotation></semantics></math>
be the indicator whether patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
in treatment arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 0,1</annotation></semantics></math>
is at risk at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>δ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\delta_{i}</annotation></semantics></math>
be the binary event indicator for patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
Then the derived outcomes are defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>O</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>τ</mi></msubsup><mfrac><mrow><mo stretchy="false" form="prefix">{</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mi>k</mi></msup></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mrow><mo stretchy="true" form="prefix">{</mo><mi>d</mi><msub><mi>N</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mfrac><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mover><mi>N</mi><mo accent="true">¯</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mfrac><mrow><mo stretchy="false" form="prefix">{</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mi>k</mi></msup></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>δ</mi><mi>i</mi></msub><mi>𝕀</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo>=</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mfrac><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mi>m</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mi>n</mi></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mi>θ</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
O_{ik}(\theta) 
&amp;= \int_{0}^{\tau} 
\frac{
  \{\exp(\theta) \overline{Y}_{1}(t)\}^{(1-k)}
  \{\overline{Y}_{0}(t)\}^{k}
}{\overline{Y}_{\theta}(t)} 
\left\{ 
  dN_{ik}(t) - 
\frac{Y_{ik}(t) \exp(\theta) d\overline{N}(t)}
{\overline{Y}_{\theta}(t)} 
\right\}
\\
&amp;= 
\sum_{j=1}^{m}
\frac{
  \{\exp(\theta) \overline{Y}_{1}(t_{j})\}^{(1-k)}
  \{\overline{Y}_{0}(t_{j})\}^{k}
}{\overline{Y}_{\theta}(t_{j})} 
\left\{ 
  \delta_{i} \mathbb{I}(t_{j} = t_{i}) - 
\frac{Y_{ik}(t_{j}) \exp(\theta) m(t_{j}) / n}
{\overline{Y}_{\theta}(t_{j})} 
\right\}
\end{align*}
</annotation></semantics></math></p>
<p>where we can see that the count measure integral was again replaced
by a sum over the unique event times
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>j</mi></msub><mo>,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">t_{j}, j = 1, \dotsc, m</annotation></semantics></math>.</p>
<p>Second, given the derived outcomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O_{ik}(\theta)</annotation></semantics></math>,
the coefficients estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mi>k</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{k}(\theta)</annotation></semantics></math>
for treatment arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 0, 1</annotation></semantics></math>
is defined as the solution to the least squares problem with the
centered covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">¯</mo></mover><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">X_{i} - \overline{X}_{k}</annotation></semantics></math>
(therefore no constant intercept column in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_{i}</annotation></semantics></math>)
and responses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O_{ik}(\theta)</annotation></semantics></math>.</p>
<p>Finally, we can define the variance estimator as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mrow><mi>C</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><msub><mover><mi mathvariant="normal">Σ</mi><mo accent="true">̂</mo></mover><mi>X</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\sigma_{CL}^{2}(\theta) =
\sigma_{L}^{2}(\theta) - 
  \hat{\pi}(1 - \hat{\pi}) 
  (\hat{\beta}_{0}(\theta_{L}) + \hat{\beta}_{1}(\theta_{L}))^{\top}
  \hat{\Sigma}_{X}
  (\hat{\beta}_{0}(\theta_{L}) + \hat{\beta}_{1}(\theta_{L}))
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>I</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\pi} = \frac{1}{n} \sum_{i=1}^{n} I_{i}</annotation></semantics></math>
is the proportion of patients in treatment arm 1, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi mathvariant="normal">Σ</mi><mo accent="true">̂</mo></mover><mi>X</mi></msub><annotation encoding="application/x-tex">\hat{\Sigma}_{X}</annotation></semantics></math>
is the sample covariance matrix of the centered covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><mover><mi>X</mi><mo accent="true">¯</mo></mover></mrow><annotation encoding="application/x-tex">X_{i} - \overline{X}</annotation></semantics></math>
(where the average is now taken across all patients, not just within
treatment arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>).</p>
<p>Similarly as the for the score function defined above, the right hand
side of the variance estimator is evaluated at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta = 0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mi>L</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_{L} = 0</annotation></semantics></math>
when calculating the covariate adjusted log-rank test statistic.</p>
<p>However, when estimating the covariate adjusted log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CL}</annotation></semantics></math>,
the regression coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{0}(\hat{\theta}_{L})</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{1}(\hat{\theta}_{L})</annotation></semantics></math>
are fixed at the unadjusted log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><annotation encoding="application/x-tex">\hat{\theta}_{L}</annotation></semantics></math>
in this expression for the standard error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CL}</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msqrt><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><msub><mover><mi mathvariant="normal">Σ</mi><mo accent="true">̂</mo></mover><mi>X</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow></msqrt><mrow><msqrt><mi>n</mi></msqrt><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><annotation encoding="application/x-tex">
\frac{\sqrt{
  \sigma_{L}^{2}(\hat{\theta}_{CL}) - 
  \hat{\pi}(1 - \hat{\pi}) 
  (\hat{\beta}_{0}(\hat{\theta}_{L}) + \hat{\beta}_{1}(\hat{\theta}_{L}))^{\top}
  \hat{\Sigma}_{X}
  (\hat{\beta}_{0}(\hat{\theta}_{L}) + \hat{\beta}_{1}(\hat{\theta}_{L}))
}}{
  \sqrt{n} \sigma_{L}^{2}(\hat{\theta}_{CL}) 
}
</annotation></semantics></math></p>
<p>This is the published version of the variance estimator when used for
estimating the standard error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CL}</annotation></semantics></math>
via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{L}^{2}(\hat{\theta}_{CL})</annotation></semantics></math>,
which is the default in <code>RobinCar2</code>. However, there is also
an alternative version which we call “unadjusted” where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{L}^{2}(\hat{\theta}_{CL})</annotation></semantics></math>
on the right hand side of the definition is replaced by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>L</mi><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{L}^{2}(\hat{\theta}_{L})</annotation></semantics></math>.
That is, the log-rank score variance estimator is evaluated at the
unadjusted log hazard ratio estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mi>L</mi></msub><annotation encoding="application/x-tex">\hat{\theta}_{L}</annotation></semantics></math>,
rather than at the covariate adjusted log hazard ratio estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CL}</annotation></semantics></math>.
This version is available via the option
<code>hr_se_plugin_adjusted = FALSE</code>, and is the version
implemented in the <code>RobinCar</code> package.</p>
<p>Note that the results will differ only very slightly. Both resulting
standard errors are consistent and valid. One motivation for the
unadjusted version is that it is guaranteed to be smaller than the
standard error of the unadjusted log hazard ratio, due to the fact that
the correction term is always positive.</p>
<p>This score function and the variance estimator are implemented in the
internal function <code>RobinCar2:::h_lr_score_cov()</code>.</p>
</div>
<div class="section level3">
<h3 id="covariate-adjusted-and-stratified-analysis">Covariate adjusted and stratified analysis<a class="anchor" aria-label="anchor" href="#covariate-adjusted-and-stratified-analysis"></a>
</h3>
<p>Finally, using both covariate adjustment and stratification,
following Section S2.3 in <span class="citation">Ye, Shao, and Yi
(2023)</span>, the score function is given by:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>U</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munder><mo>∑</mo><mi>z</mi></munder><munder><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><msub><mi>Z</mi><mi>i</mi></msub><mo>=</mo><mi>z</mi></mrow></munder><mo stretchy="false" form="prefix">{</mo><msub><mi>I</mi><mi>i</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">¯</mo></mover><mi>z</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>I</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">¯</mo></mover><mi>z</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
U_{CSL}(\theta) =
U_{SL}(\theta) - \frac{1}{n} \sum_{z} \sum_{i: Z_{i} = z}
\{
I_{i}(X_{i} - \overline{X}_{z})^{\top} \hat{\beta}_{1}(\theta_{SL}) - 
(1 - I_{i})(X_{i} - \overline{X}_{z})^{\top} \hat{\beta}_{0}(\theta_{SL}) 
\},
</annotation></semantics></math></p>
<p>which shows us that it is based on the score function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">U_{SL}(\theta)</annotation></semantics></math>
from the stratified but not covariate-adjusted log-rank test. The
correction term is added up over the strata
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>,
but based on overall regression coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{0}(\theta_{SL})</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{1}(\theta_{SL})</annotation></semantics></math>.</p>
<p>Similarly as for the unstratified covariate adjusted log-rank test,
the derived outcomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>z</mi><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O_{zik}(\theta)</annotation></semantics></math>
in stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
are defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>O</mi><mrow><mi>z</mi><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>τ</mi></msubsup><mfrac><mrow><mo stretchy="false" form="prefix">{</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>0</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mi>k</mi></msup></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>θ</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mrow><mo stretchy="true" form="prefix">{</mo><mi>d</mi><msub><mi>N</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mfrac><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><msub><mover><mi>N</mi><mo accent="true">¯</mo></mover><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>θ</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><munder><mo>∑</mo><mrow><mi>j</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow></munder><mfrac><mrow><mo stretchy="false" form="prefix">{</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mrow><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>0</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">}</mo><mi>k</mi></msup></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>θ</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>δ</mi><mi>i</mi></msub><mi>𝕀</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo>=</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mfrac><mrow><msub><mi>Y</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mi>m</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mi>n</mi></mrow><mrow><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>θ</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
O_{zik}(\theta) 
&amp;= \int_{0}^{\tau} 
\frac{
  \{\exp(\theta) \overline{Y}_{z1}(t)\}^{(1-k)}
  \{\overline{Y}_{z0}(t)\}^{k}
}{\overline{Y}_{z\theta}(t)} 
\left\{ 
  dN_{ik}(t) - 
\frac{Y_{ik}(t) \exp(\theta) d\overline{N}_{z}(t)}
{\overline{Y}_{z\theta}(t)} 
\right\}
\\
&amp;= 
\sum_{j(z)}
\frac{
  \{\exp(\theta) \overline{Y}_{z1}(t_{j})\}^{(1-k)}
  \{\overline{Y}_{z0}(t_{j})\}^{k}
}{\overline{Y}_{z\theta}(t_{j})} 
\left\{ 
  \delta_{i} \mathbb{I}(t_{j} = t_{i}) - 
\frac{Y_{ik}(t_{j}) \exp(\theta) m_{z}(t_{j}) / n}
{\overline{Y}_{z\theta}(t_{j})} 
\right\}
\end{align*}
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>z</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><msub><mi>Z</mi><mi>i</mi></msub><mo>=</mo><mi>z</mi></mrow></msub><msub><mi>δ</mi><mi>i</mi></msub><mi>𝕀</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>j</mi></msub><mo>=</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">m_{z}(t_{j}) = \sum_{i: Z_{i} = z} \delta_{i} \mathbb{I}(t_{j} = t_{i})</annotation></semantics></math>
is the number of events in stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
at the unique event time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>j</mi></msub><annotation encoding="application/x-tex">t_{j}</annotation></semantics></math>,
and we further abbreviated</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mrow><mi>z</mi><mi>θ</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>0</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mrow><mi>exp</mi><mo>⁡</mo></mrow><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><msub><mover><mi>Y</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mn>1</mn></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
Y_{z\theta}(t) = \overline{Y}_{z0}(t) + \exp(\theta) \overline{Y}_{z1}(t).
</annotation></semantics></math></p>
<p>Now as a second step, given the derived outcomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>z</mi><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O_{zik}(\theta)</annotation></semantics></math>,
the coefficients estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mi>k</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{k}(\theta)</annotation></semantics></math>
for treatment arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 0, 1</annotation></semantics></math>
is defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mi>k</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">{</mo><munder><mo>∑</mo><mi>z</mi></munder><munder><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><msub><mi>I</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo>,</mo><msub><mi>Z</mi><mi>i</mi></msub><mo>=</mo><mi>z</mi></mrow></munder><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>k</mi></mrow></msub><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><mo stretchy="true" form="postfix">}</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><munder><mo>∑</mo><mi>z</mi></munder><munder><mo>∑</mo><mrow><mi>i</mi><mo>:</mo><msub><mi>I</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo>,</mo><msub><mi>Z</mi><mi>i</mi></msub><mo>=</mo><mi>z</mi></mrow></munder><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>X</mi><mo accent="true">¯</mo></mover><mrow><mi>z</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><msub><mi>O</mi><mrow><mi>z</mi><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
\hat{\beta}_{k}(\theta) = 
\left\{
  \sum_{z} \sum_{i: I_{i} = k, Z_{i} = z}
  (X_{i} - \overline{X}_{zk})
  (X_{i} - \overline{X}_{zk})^{\top}
\right\}^{-1}
\sum_{z} \sum_{i: I_{i} = k, Z_{i} = z}
  (X_{i} - \overline{X}_{zk})
  O_{zik}(\theta).
</annotation></semantics></math></p>
<p>So we see that within each treatment group and within each stratum,
the covariates are centered separately, and the required cross-products
are added from all strata. Finally the coefficient estimates are
obtained by solving the least squares problem with the derived outcomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>z</mi><mi>i</mi><mi>k</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O_{zik}(\theta)</annotation></semantics></math>
as responses.</p>
<p>Finally, the variance estimator is defined very similarly to the
covariate adjusted but unstratified log-rank test:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>θ</mi><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><mrow><mo stretchy="true" form="prefix">{</mo><munder><mo>∑</mo><mi>z</mi></munder><msub><mi>n</mi><mi>z</mi></msub><mi>/</mi><mi>n</mi><msub><mover><mi mathvariant="normal">Σ</mi><mo accent="true">̂</mo></mover><mrow><mi>X</mi><mo stretchy="false" form="postfix">|</mo><mi>z</mi></mrow></msub><mo stretchy="true" form="postfix">}</mo></mrow><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\sigma_{CSL}^{2}(\theta) =
\sigma_{SL}^{2}(\theta) - 
  \hat{\pi}(1 - \hat{\pi}) 
  (\hat{\beta}_{0}(\theta_{SL}) + \hat{\beta}_{1}(\theta_{SL}))^{\top}
  \left\{\sum_{z} n_z / n \hat{\Sigma}_{X\vert z}\right\}
  (\hat{\beta}_{0}(\theta_{SL}) + \hat{\beta}_{1}(\theta_{SL}))
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>z</mi></msub><annotation encoding="application/x-tex">n_z</annotation></semantics></math>
is the number of patients in stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi mathvariant="normal">Σ</mi><mo accent="true">̂</mo></mover><mrow><mi>X</mi><mo stretchy="false" form="postfix">|</mo><mi>z</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\Sigma}_{X\vert z}</annotation></semantics></math>
is the sample covariance matrix of the original covariates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_{i}</annotation></semantics></math>
within stratum
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>.</p>
<p>In the same way as for the unstratified case, when estimating the
covariate adjusted stratified log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CSL}</annotation></semantics></math>,
the regression coefficients
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{0}(\hat{\theta}_{SL})</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\hat{\beta}_{1}(\hat{\theta}_{SL})</annotation></semantics></math>
are fixed at the unadjusted log hazard ratio
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{SL}</annotation></semantics></math>
in this expression for the standard error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CSL}</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msqrt><mrow><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mover><mi>π</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mi>⊤</mi></msup><mo stretchy="false" form="prefix">{</mo><munder><mo>∑</mo><mi>z</mi></munder><msub><mi>n</mi><mi>z</mi></msub><mi>/</mi><mi>n</mi><msub><mover><mi mathvariant="normal">Σ</mi><mo accent="true">̂</mo></mover><mrow><mi>X</mi><mo stretchy="false" form="postfix">|</mo><mi>z</mi></mrow></msub><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><msub><mover><mi>β</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow></msqrt><mrow><msqrt><mi>n</mi></msqrt><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><annotation encoding="application/x-tex">
\frac{\sqrt{
  \sigma_{SL}^{2}(\hat{\theta}_{CSL}) - 
  \hat{\pi}(1 - \hat{\pi}) 
  (\hat{\beta}_{0}(\hat{\theta}_{SL}) + \hat{\beta}_{1}(\hat{\theta}_{SL}))^{\top}
  \{\sum_{z} n_z / n \hat{\Sigma}_{X\vert z}\}
  (\hat{\beta}_{0}(\hat{\theta}_{SL}) + \hat{\beta}_{1}(\hat{\theta}_{SL}))
}}{
  \sqrt{n} \sigma_{SL}^{2}(\hat{\theta}_{CSL}) 
}
</annotation></semantics></math></p>
<p>This is the published version of the variance estimator when used for
estimating the standard error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CSL}</annotation></semantics></math>
via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{SL}^{2}(\hat{\theta}_{CSL})</annotation></semantics></math>,
which is the default in <code>RobinCar2</code>. However, there is also
an alternative version which we call “unadjusted” where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{SL}^{2}(\hat{\theta}_{CSL})</annotation></semantics></math>
on the right hand side of the definition is replaced by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mrow><mi>S</mi><mi>L</mi></mrow><mn>2</mn></msubsup><mo stretchy="false" form="prefix">(</mo><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{SL}^{2}(\hat{\theta}_{SL})</annotation></semantics></math>.
That is, the log-rank score variance estimator is evaluated at the
unadjusted log hazard ratio estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>S</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{SL}</annotation></semantics></math>,
rather than at the covariate adjusted log hazard ratio estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>θ</mi><mo accent="true">̂</mo></mover><mrow><mi>C</mi><mi>S</mi><mi>L</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\theta}_{CSL}</annotation></semantics></math>.
This version is available via the option
<code>hr_se_plugin_adjusted = FALSE</code>, and is the version
implemented in the <code>RobinCar</code> package.</p>
<p>Note that the results will differ only very slightly. Both resulting
standard errors are consistent and valid. One motivation for the
unadjusted version is that it is guaranteed to be smaller than the
standard error of the unadjusted log hazard ratio, due to the fact that
the correction term is always positive.</p>
<p>This score function and the variance estimator are implemented in the
internal function <code>RobinCar2:::h_lr_score_strat_cov()</code>.</p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-YeShaoYi2023" class="csl-entry">
Ye, Ting, Jun Shao, and Yanyao Yi. 2023. <span>“Covariate-Adjusted
Log-Rank Test: Guaranteed Efficiency Gain and Universal
Applicability.”</span> <em>Biometrika</em> 111 (2): 691–705. <a href="https://doi.org/10.1093/biomet/asad045" class="external-link">https://doi.org/10.1093/biomet/asad045</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Liming Li, Marlena Bannick, Daniel Sabanes Bove, Dong Xi, Ting Ye, Yanyao Yi, Gilead Sciences, Inc., F. Hoffmann-La Roche AG, Merck Sharp &amp; Dohme, Inc., AstraZeneca plc, Eli Lilly and Company, Novartis Pharma AG, The University of Washington.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
